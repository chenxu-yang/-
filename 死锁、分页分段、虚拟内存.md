## 死锁

在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。

### 死锁产生的必要条件

* 互斥：一个资源一次只能被一个进程使用
* 占有并等待：一个进程至少占有一个资源，并在等待另一个被其他进程占有的资源
* 非抢占：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务后自愿释放
* 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系，环路中每个进程都在等待下一个进程所占有的资源

### 处理死锁的方法

* 鸵鸟策略

  直接忽略死锁

* 死锁预防

  * 破坏互斥条件
  * 破坏占有并等待条件
  * 破坏非抢占条件
  * 破坏循环等待条件

* 死锁避免

  银行家算法

* 死锁解除

  >检测死锁：检测有向图是否存在环



## 分页和分段

分段和分页是为了利用和管理好计算机的资源--内存

* #### 为什么需要分段和分页？

  之前，程序运行需要从内存中分配连续内存，将整个程序装进去

  会出现以下问题

  * **地址空间不隔离**

    操作地址错了，影响其他程序

  * **程序运行时地址不确定**

    如果在程序中固定了操作某个地址的内存，但是不同时间可能装载位置不同

  * **内存使用率低下**

* #### 虚拟内存

  每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。

  虚拟内存的优点是让程序可以获得更多的可用内存。

* #### 分段技术

  引入虚拟空间地址：虚拟地址空间可以是任意大的，物理地址空间是有限的

  分段将虚拟地址空间映射到了物理地址空间。

  可以解决一二问题，但是第三个问题的关键是能不能在换出一个完整的程序之后，把另一个完整的程序换进来。而分段机制，映射的是一片连续的物理内存，所以问题三得不到解决。

  分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。

* #### 分页技术

  分页这个技术仍然是一种虚拟地址空间到物理地址空间映射的机制。但是，粒度更加的小了。单位不是整个程序，而是某个“页”，一段虚拟地址空间组成的某一页映射到一段物理地址空间组成的某一页。但是，每一页映射后的物理地址就不一定是连续的了。正是因为有了分页的概念，程序的换入换出就可以以页为单位了。

  

* ### 分页和分段有什么区别？

  - 页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；
  - 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；
  - 段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。

  区别：

  - 目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；
  - 大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；
  - 地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；
  - 分段便于信息的保护和共享；分页的共享收到限制；
  - 碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）

* #### 页面置换算法

  在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

  * **最佳页面置换算法**OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；
  * **先进先出**FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；
  * **第二次机会算法**SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；
  * **时钟算法** Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；
  * **最近未使用算法**NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；
  * **最近最少使用算法**LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。
  * **最不经常使用算法**NFU：置换出访问次数最少的页面



